---
sidebar: sidebar 
permalink: get-started/create-kubeconfig.html 
keywords: kubeconfig, create, config file, file, config 
summary: Sie müssen eine kubeconfig-Datei für selbstverwaltete Cluster erstellen. 
---
= Erstellen Sie eine kubeconfig-Datei
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/get-started/


[role="lead"]
Sie können dem Astra Control Service ein Cluster mithilfe einer kubeconfig-Datei hinzufügen. Je nach dem Typ des Clusters, den Sie hinzufügen möchten, müssen Sie möglicherweise manuell eine kubeconfig-Datei für Ihr Cluster mithilfe bestimmter Schritte erstellen.

* <<Erstellen Sie eine kubeconfig-Datei für Amazon EKS-Cluster>>
* <<Erstellen Sie eine kubeconfig-Datei für Red hat OpenShift Service on AWS (ROSA) Cluster>>
* <<Erstellen Sie eine kubeconfig-Datei für andere Cluster-Typen>>




== Erstellen Sie eine kubeconfig-Datei für Amazon EKS-Cluster

Befolgen Sie diese Anweisungen, um eine kubeconfig-Datei und ein permanentes Token-Geheimnis für Amazon EKS-Cluster zu erstellen. Für Cluster, die in EKS gehostet werden, ist ein permanenter Tokenschlüssel erforderlich.

.Schritte
. Befolgen Sie die Anweisungen in der Amazon-Dokumentation, um eine kubeconfig-Datei zu erstellen:
+
https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html["Erstellen oder Aktualisieren einer kubeconfig-Datei für einen Amazon EKS-Cluster"^]

. Erstellen Sie ein Service-Konto wie folgt:
+
.. Erstellen Sie eine Dienstkontendatei mit dem Namen `astracontrol-service-account.yaml`.
+
Passen Sie den Namen des Servicekontos nach Bedarf an. Der Namespace `kube-system` Ist für diese Schritte erforderlich. Wenn Sie hier den Namen des Servicekontos ändern, sollten Sie die gleichen Änderungen in den folgenden Schritten anwenden.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: astra-admin-account
  namespace: kube-system
----


. Wenden Sie das Servicekonto an:
+
[source, console]
----
kubectl apply -f astracontrol-service-account.yaml
----
. Erstellen Sie ein `ClusterRoleBinding` Datei aufgerufen `astracontrol-clusterrolebinding.yaml`.
+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-clusterrolebinding.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: astra-admin-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: astra-admin-account
  namespace: kube-system
----
. Wenden Sie die Bindung der Cluster-Rolle an:
+
[source, console]
----
kubectl apply -f astracontrol-clusterrolebinding.yaml
----
. Erstellen Sie eine Geheimdatei für das Dienstkonto-Token mit dem Namen `astracontrol-secret.yaml`.
+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-secret.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: astra-admin-account
  name: astra-admin-account
  namespace: kube-system
type: kubernetes.io/service-account-token
----
. Wenden Sie den Token-Schlüssel an:
+
[source, console]
----
kubectl apply -f astracontrol-secret.yaml
----
. Rufen Sie den Token-Schlüssel ab:
+
[source, console]
----
kubectl get secret astra-admin-account -n kube-system -o jsonpath='{.data.token}' | base64 -d
----
. Ersetzen Sie den `user` Abschnitt der AWS EKS kubeconfig-Datei mit dem Token, wie im folgenden Beispiel gezeigt:
+
[source, yaml]
----
user:
    token: k8s-aws-v1.aHR0cHM6Ly9zdHMudXMtd2VzdC0yLmFtYXpvbmF3cy5jb20vP0FjdGlvbj1HZXRDYWxsZXJJZGVudGl0eSZWZXJzaW9uPTIwMTEtMDYtMTUmWC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBM1JEWDdKU0haWU9LSEQ2SyUyRjIwMjMwNDAzJTJGdXMtd2VzdC0yJTJGc3RzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA0MDNUMjA0MzQwWiZYLUFtei1FeHBpcmVzPTYwJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCUzQngtazhzLWF3cy1pZCZYLUFtei1TaWduYXR1cmU9YjU4ZWM0NzdiM2NkZGYxNGRhNzU4MGI2ZWQ2zY2NzI2YWIwM2UyNThjMjRhNTJjNmVhNjc4MTRlNjJkOTg2Mg
----




== Erstellen Sie eine kubeconfig-Datei für Red hat OpenShift Service on AWS (ROSA) Cluster

Befolgen Sie diese Anweisungen, um eine kubeconfig-Datei für Red hat OpenShift Service on AWS (ROSA)-Cluster zu erstellen.

.Schritte
. Melden Sie sich beim ROSA-Cluster an.
. Service-Konto erstellen:
+
[source, console]
----
oc create sa astracontrol-service-account
----
. Cluster-Rolle hinzufügen:
+
[source, console]
----
oc adm policy add-cluster-role-to-user cluster-admin -z astracontrol-service-account
----
. Erstellen Sie mithilfe des folgenden Beispiels eine geheime Konfigurationsdatei für das Dienstkonto:
+
[source, subs="specialcharacters,quotes"]
----
*secret-astra-sa.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: secret-astracontrol-service-account
  annotations:
    kubernetes.io/service-account.name: "astracontrol-service-account"
type: kubernetes.io/service-account-token
----
. Erstellen Sie das Geheimnis:
+
[source, console]
----
oc create -f secret-astra-sa.yaml
----
. Bearbeiten Sie das von Ihnen erstellte Dienstkonto, und fügen Sie dem den geheimen Namen des Astra Control-Dienstkontos hinzu `secrets` Abschnitt:
+
[source, console]
----
oc edit sa astracontrol-service-account
----
+
[source, yaml]
----
apiVersion: v1
imagePullSecrets:
- name: astracontrol-service-account-dockercfg-dvfcd
kind: ServiceAccount
metadata:
  creationTimestamp: "2023-08-04T04:18:30Z"
  name: astracontrol-service-account
  namespace: default
  resourceVersion: "169770"
  uid: 965fa151-923f-4fbd-9289-30cad15998ac
secrets:
- name: astracontrol-service-account-dockercfg-dvfcd
- name: secret-astracontrol-service-account ####ADD THIS ONLY####
----
. Listen Sie die Geheimnisse des Dienstkontos auf, ersetzen Sie `<CONTEXT>` Mit dem richtigen Kontext für Ihre Installation:
+
[source, console]
----
kubectl get serviceaccount astracontrol-service-account --context <CONTEXT> --namespace default -o json
----
+
Das Ende der Ausgabe sollte wie folgt aussehen:

+
[listing]
----
"secrets": [
{ "name": "astracontrol-service-account-dockercfg-dvfcd"},
{ "name": "secret-astracontrol-service-account"}
]
----
+
Die Indizes für jedes Element im `secrets` Array beginnt mit 0. Im obigen Beispiel der Index für `astracontrol-service-account-dockercfg-dvfcd` Wäre 0 und der Index für `secret-astracontrol-service-account` Sind es 1. Notieren Sie sich in Ihrer Ausgabe die Indexnummer für den Geheimschlüssel des Dienstkontos. Diese Indexnummer benötigen Sie im nächsten Schritt.

. Erzeugen Sie den kubeconfig wie folgt:
+
.. Erstellen Sie ein `create-kubeconfig.sh` Datei: Austausch `TOKEN_INDEX` Am Anfang des folgenden Skripts mit dem korrekten Wert.
+
[source, subs="specialcharacters,quotes"]
----
*create-kubeconfig.sh*
----
+
[source, bash]
----
# Update these to match your environment.
# Replace TOKEN_INDEX with the correct value
# from the output in the previous step. If you
# didn't change anything else above, don't change
# anything else here.

SERVICE_ACCOUNT_NAME=astracontrol-service-account
NAMESPACE=default
NEW_CONTEXT=astracontrol
KUBECONFIG_FILE='kubeconfig-sa'

CONTEXT=$(kubectl config current-context)

SECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.secrets[TOKEN_INDEX].name}')
TOKEN_DATA=$(kubectl get secret ${SECRET_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.data.token}')

TOKEN=$(echo ${TOKEN_DATA} | base64 -d)

# Create dedicated kubeconfig
# Create a full copy
kubectl config view --raw > ${KUBECONFIG_FILE}.full.tmp

# Switch working context to correct context
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp config use-context ${CONTEXT}

# Minify
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp \
  config view --flatten --minify > ${KUBECONFIG_FILE}.tmp

# Rename context
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  rename-context ${CONTEXT} ${NEW_CONTEXT}

# Create token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-credentials ${CONTEXT}-${NAMESPACE}-token-user \
  --token ${TOKEN}

# Set context to use token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --user ${CONTEXT}-${NAMESPACE}-token-user

# Set context to correct namespace
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --namespace ${NAMESPACE}

# Flatten/minify kubeconfig
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  view --flatten --minify > ${KUBECONFIG_FILE}

# Remove tmp
rm ${KUBECONFIG_FILE}.full.tmp
rm ${KUBECONFIG_FILE}.tmp
----
.. Geben Sie die Befehle an, um sie auf Ihren Kubernetes-Cluster anzuwenden.
+
[source, console]
----
source create-kubeconfig.sh
----


. (Optional) Umbenennen Sie die kubeconfig auf einen aussagekräftigen Namen für Ihr Cluster.
+
[listing]
----
mv kubeconfig-sa YOUR_CLUSTER_NAME_kubeconfig
----




== Erstellen Sie eine kubeconfig-Datei für andere Cluster-Typen

Befolgen Sie diese Anweisungen, um eine kubeconfig-Datei für Rancher-, Upstream-Kubernetes- und Red hat OpenShift-Cluster zu erstellen.

.Bevor Sie beginnen
Vergewissern Sie sich vor dem Start, dass Folgendes auf dem Gerät vorhanden ist:

* Kubectl v1.25 oder höher installiert
* Kubectl Zugriff auf den Cluster, den Sie mit Astra Control Center hinzufügen und verwalten möchten
+

NOTE: Bei diesem Verfahren benötigen Sie keinen kubectl-Zugriff auf den Cluster, auf dem Astra Control Center ausgeführt wird.

* Ein aktiver kubeconfig für den Cluster, den Sie mit Clusteradministratorrechten für den aktiven Kontext verwalten möchten


.Schritte
. Service-Konto erstellen:
+
.. Erstellen Sie eine Dienstkontendatei mit dem Namen `astracontrol-service-account.yaml`.
+
Passen Sie Namen und Namespace nach Bedarf an. Wenn hier Änderungen vorgenommen werden, sollten Sie die gleichen Änderungen in den folgenden Schritten anwenden.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: astracontrol-service-account
  namespace: default
----
.. Wenden Sie das Servicekonto an:
+
[source, console]
----
kubectl apply -f astracontrol-service-account.yaml
----


. Erstellen Sie eine der folgenden Clusterrollen mit ausreichenden Berechtigungen für ein Cluster, das von Astra Control gemanagt werden kann:
+
** *Begrenzte Clusterrolle*: Diese Rolle enthält die Mindestberechtigungen, die für die Verwaltung eines Clusters durch Astra Control erforderlich sind:
+
.Für Schritte erweitern
[%collapsible]
====
... Erstellen Sie ein `ClusterRole` Datei mit dem Namen, z. B. `astra-admin-account.yaml`.
+
Passen Sie Namen und Namespace nach Bedarf an. Wenn hier Änderungen vorgenommen werden, sollten Sie die gleichen Änderungen in den folgenden Schritten anwenden.

+
[source, subs="specialcharacters,quotes"]
----
*astra-admin-account.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: astra-admin-account
rules:

# Justification for resource permissions:

# Astra Control needs to be able to discover (list) resources of all types within your application.
# These permissions are required to discover, back up, and restore your application resources including
# secrets.
# For example, if your application contains custom resources or cluster-scoped resources, Astra Control
# needs '*' to discover, back up, and restore your application resources.

# Justification for Verbs:
# - "List" enables discovery.
# - "Get" enables resource backups and enables users to define apps using GVK.
# - "Create" enables restoring an application from a snapshot or backup using Astra Control.
# - "Delete" enables application resource clean-up as part of an in-place restore of an application or clones.
# - "Patch" enables maintaining owner references and updating labels on some resources.
# - "Update" enables replica scaling in case of operations like in-place restores of your application.
# - "Watch" enables Astra Control to keep an up to date view of resources.

# Manage all resources
# Necessary to back up and restore all resources in an app
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - get
  - list
  - create
  - patch
  - delete
  - watch
  - update

- nonResourceURLs:
  - /metrics
  verbs:
  - get
  - watch
  - list

# Use PodSecurityPolicies
- apiGroups:
  - extensions
  - policy
  resources:
  - podsecuritypolicies
  verbs:
  - use

# OpenShift security - uncomment the following lines for Red Hat OpenShift clusters
#- apiGroups:
#  - security.openshift.io
#  resources:
#  - securitycontextconstraints
#  verbs:
#  - use
----
... (Nur für OpenShift-Cluster) Wenn Sie einen kubeconfig für einen OpenShift-Cluster erstellen, heben Sie die Kommentare für die endgültigen Zeilen im auf `astra-admin-account.yaml` Datei nach dem `# Use PodSecurityPolicies` Abschnitt:
+
[source, console]
----
# OpenShift security
- apiGroups:
  - security.openshift.io
  resources:
  - securitycontextconstraints
  verbs:
  - use
----
... Wenden Sie die Cluster-Rolle an:
+
[source, console]
----
kubectl apply -f astra-admin-account.yaml
----


====
** *Erweiterte Clusterrolle*: Diese Rolle enthält erweiterte Berechtigungen für einen Cluster, der von Astra Control verwaltet werden soll. Sie können diese Rolle verwenden, wenn Sie mehrere Kontexte verwenden und nicht den während der Installation konfigurierten Astra Control kubeconfig verwenden können oder eine eingeschränkte Rolle mit einem einzelnen Kontext in Ihrer Umgebung nicht funktioniert:
+

NOTE: Im Folgenden `ClusterRole` Schritte sind ein allgemeines Kubernetes-Beispiel. Anweisungen zu Ihrer spezifischen Umgebung finden Sie in der Dokumentation zur Kubernetes-Distribution.

+
.Für Schritte erweitern
[%collapsible]
====
... Erstellen Sie ein `ClusterRole` Datei mit dem Namen, z. B. `astra-admin-account.yaml`.
+
Passen Sie Namen und Namespace nach Bedarf an. Wenn hier Änderungen vorgenommen werden, sollten Sie die gleichen Änderungen in den folgenden Schritten anwenden.

+
[source, subs="specialcharacters,quotes"]
----
*astra-admin-account.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: astra-admin-account
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - '*'
- nonResourceURLs:
  - '*'
  verbs:
  - '*'
----
... Wenden Sie die Cluster-Rolle an:
+
[source, console]
----
kubectl apply -f astra-admin-account.yaml
----


====


. Erstellen Sie die Cluster-Rolle, die für die Cluster-Rolle an das Service-Konto gebunden ist:
+
.. Erstellen Sie ein `ClusterRoleBinding` Datei aufgerufen `astracontrol-clusterrolebinding.yaml`.
+
Passen Sie bei Bedarf alle beim Erstellen des Dienstkontos geänderten Namen und Namespaces an.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-clusterrolebinding.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: astracontrol-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: astra-admin-account
subjects:
- kind: ServiceAccount
  name: astracontrol-service-account
  namespace: default
----
.. Wenden Sie die Bindung der Cluster-Rolle an:
+
[source, console]
----
kubectl apply -f astracontrol-clusterrolebinding.yaml
----


. Erstellen und Anwenden des Token-Geheimnisses:
+
.. Erstellen Sie eine Geheimdatei mit dem Namen Token `secret-astracontrol-service-account.yaml`.
+
[source, subs="specialcharacters,quotes"]
----
*secret-astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: secret-astracontrol-service-account
  namespace: default
  annotations:
    kubernetes.io/service-account.name: "astracontrol-service-account"
type: kubernetes.io/service-account-token
----
.. Wenden Sie den Token-Schlüssel an:
+
[source, console]
----
kubectl apply -f secret-astracontrol-service-account.yaml
----


. Fügen Sie dem Dienstkonto den Token-Schlüssel hinzu, indem Sie den Namen dem hinzufügen `secrets` Array (die letzte Zeile im folgenden Beispiel):
+
[source, console]
----
kubectl edit sa astracontrol-service-account
----
+
[source, subs="verbatim,quotes"]
----
apiVersion: v1
imagePullSecrets:
- name: astracontrol-service-account-dockercfg-48xhx
kind: ServiceAccount
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"ServiceAccount","metadata":{"annotations":{},"name":"astracontrol-service-account","namespace":"default"}}
  creationTimestamp: "2023-06-14T15:25:45Z"
  name: astracontrol-service-account
  namespace: default
  resourceVersion: "2767069"
  uid: 2ce068c4-810e-4a96-ada3-49cbf9ec3f89
secrets:
- name: astracontrol-service-account-dockercfg-48xhx
*- name: secret-astracontrol-service-account*
----
. Listen Sie die Geheimnisse des Dienstkontos auf, ersetzen Sie `<CONTEXT>` Mit dem richtigen Kontext für Ihre Installation:
+
[source, console]
----
kubectl get serviceaccount astracontrol-service-account --context <CONTEXT> --namespace default -o json
----
+
Das Ende der Ausgabe sollte wie folgt aussehen:

+
[listing]
----
"secrets": [
{ "name": "astracontrol-service-account-dockercfg-48xhx"},
{ "name": "secret-astracontrol-service-account"}
]
----
+
Die Indizes für jedes Element im `secrets` Array beginnt mit 0. Im obigen Beispiel der Index für `astracontrol-service-account-dockercfg-48xhx` Wäre 0 und der Index für `secret-astracontrol-service-account` Sind es 1. Notieren Sie sich in Ihrer Ausgabe die Indexnummer für den Geheimschlüssel des Dienstkontos. Diese Indexnummer benötigen Sie im nächsten Schritt.

. Erzeugen Sie den kubeconfig wie folgt:
+
.. Erstellen Sie ein `create-kubeconfig.sh` Datei: Austausch `TOKEN_INDEX` Am Anfang des folgenden Skripts mit dem korrekten Wert.
+
[source, subs="specialcharacters,quotes"]
----
*create-kubeconfig.sh*
----
+
[source, bash]
----
# Update these to match your environment.
# Replace TOKEN_INDEX with the correct value
# from the output in the previous step. If you
# didn't change anything else above, don't change
# anything else here.

SERVICE_ACCOUNT_NAME=astracontrol-service-account
NAMESPACE=default
NEW_CONTEXT=astracontrol
KUBECONFIG_FILE='kubeconfig-sa'

CONTEXT=$(kubectl config current-context)

SECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.secrets[TOKEN_INDEX].name}')
TOKEN_DATA=$(kubectl get secret ${SECRET_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.data.token}')

TOKEN=$(echo ${TOKEN_DATA} | base64 -d)

# Create dedicated kubeconfig
# Create a full copy
kubectl config view --raw > ${KUBECONFIG_FILE}.full.tmp

# Switch working context to correct context
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp config use-context ${CONTEXT}

# Minify
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp \
  config view --flatten --minify > ${KUBECONFIG_FILE}.tmp

# Rename context
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  rename-context ${CONTEXT} ${NEW_CONTEXT}

# Create token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-credentials ${CONTEXT}-${NAMESPACE}-token-user \
  --token ${TOKEN}

# Set context to use token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --user ${CONTEXT}-${NAMESPACE}-token-user

# Set context to correct namespace
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --namespace ${NAMESPACE}

# Flatten/minify kubeconfig
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  view --flatten --minify > ${KUBECONFIG_FILE}

# Remove tmp
rm ${KUBECONFIG_FILE}.full.tmp
rm ${KUBECONFIG_FILE}.tmp
----
.. Geben Sie die Befehle an, um sie auf Ihren Kubernetes-Cluster anzuwenden.
+
[source, console]
----
source create-kubeconfig.sh
----


. (Optional) Umbenennen Sie die kubeconfig auf einen aussagekräftigen Namen für Ihr Cluster.
+
[listing]
----
mv kubeconfig-sa YOUR_CLUSTER_NAME_kubeconfig
----

